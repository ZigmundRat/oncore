# Motorola Oncore emulator
# Copyright 2017 Thomas Petig
#
# Expecting PPS pulse on CTS
#
import time
import serial
from fcntl import ioctl
from termios import ( TIOCMIWAIT, TIOCM_RNG, TIOCM_DSR, TIOCM_CD, TIOCM_CTS)

use_utc = 1

wait_signals = (TIOCM_RNG | TIOCM_DSR | TIOCM_CD | TIOCM_CTS)

def checksum(array):
    cs = array[2]
    for i in range(3, len(array)-3):
        cs = cs ^ array[i]
    array[-3] = cs


# configure the serial connections (the parameters differs on the device you are connecting to)
ser = serial.Serial(
    port='/dev/ttyUSB3',
    baudrate=9600
)

Ea = bytearray([0x40, 0x40, 0x45, 0x61,
0x01, 0x01, 0x07, 0xCE,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x0B, 0x96, 0x4F, 0x00,
0x01, 0xEE, 0x62, 0x80,
0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x01, 0x00,
0x00, 0x00,
0x00, 0x00,
0x00, 0x00, # current DOP
0x00,       # DOP type 0 = PDOP (3d fix)
10, 8,
0x02, 8, 0xFF, 0x82,
0x04, 8, 0xFF, 0x82,
0x06, 8, 0xFF, 0x82,
0x08, 8, 0xFF, 0x82,
0x0A, 8, 0xFF, 0x82,
0x0C, 8, 0xFF, 0x82,
0x0E, 8, 0xFF, 0x82,
0x10, 8, 0xFF, 0x82,
0x20,
0xDF, 0x0D, 0x0A])

En = bytearray([0x40, 0x40, 0x45, 0x6E,
0x01,
0x00,
0x00, 0xC0,
0x01,              # pps control mode
0x00, 0x00, 0x01,  # pps rate
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, # time to next fire
0x01,        # pulse status
0x01,        # pulse ref
0x00,        # solution status
0x00,        # Time RAIM status
0x00, 0x03,  # time solution accuracy estimate
0x00,        # sawtooth
0x02, 0x00, 0x00, 0x00, 0x01,
0x04, 0x00, 0x00, 0x00, 0x02,
0x06, 0x00, 0x00, 0x00, 0x03,
0x08, 0x00, 0x00, 0x00, 0x04,
0x0A, 0x00, 0x00, 0x00, 0x05,
0x0C, 0x00, 0x00, 0x00, 0x06,
0x0E, 0x00, 0x00, 0x00, 0x00,
0x10, 0x00, 0x00, 0x00, 0x00,
0xFA, 0x0D, 0x0A])
Bb = bytearray([0x40, 0x40, 0x42, 0x62,
10,
0x02, 0x00, 0x10, 0x50, 0x00, 0x10, 0x00,
0x04, 0x00, 0x00, 0x30, 0x00, 0x20, 0x00,
0x06, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
0x08, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00,
0x0A, 0x00, 0x00, 0x5A, 0x00, 0x01, 0x00,
0x0C, 0x00, 0x00, 0x5A, 0x00, 0x02, 0x00,
0x0E, 0x00, 0x00, 0x5A, 0x00, 0x03, 0x00,
0x10, 0x00, 0x00, 0x5A, 0x00, 0x04, 0x00,
0x11, 0x00, 0x00, 0x20, 0x00, 0x05, 0x00,
0x12, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x3C, 0x0D, 0x0A])

Ap = bytearray([0x40, 0x40, 0x41, 0x70, 0x32, 0x61, 0x52, 0x99, 0x00, 0x81,
        0x01, 0x2A, 0x0F, 0x54, 0xEB, 0x8B, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x38, 0x0D, 0x0A])

Aw = bytearray([0x40, 0x40, 0x41, 0x77,
0x01, # 0 = GPS time, 1 = UTC time
0x36, 0x0D, 0x0A])

Ag = bytearray([0x40, 0x40, 0x41, 0x67, 0x0A, 0x2C, 0x0D, 0x0A])

At = bytearray([0x40, 0x40, 0x41, 0x74,
0x01,
0x34, 0x0D, 0x0A])

Az = bytearray([0x40, 0x40, 0x41, 0x7A, 0x00, 0x00, 0x00, 0x00, 0x3B, 0x0D, 0x0A])

Bj = bytearray([0x40, 0x40, 0x42, 0x6A, 0x00, 0x28, 0x0D, 0x0A])

Bo = bytearray([0x40, 0x40, 0x42, 0x6F, 0x00, 0x2D, 0x0D, 0x0A])

Ec = bytearray(['@', '@', 'E', 'c',
1,
1,
8,
0,
10,
2,
4,
6,
8,
10,
12,
14,
16,
0x00,
0x0D,
0x0A])

ser.isOpen()

secs = 0;

while True:
    ioctl(ser.fd, TIOCMIWAIT, wait_signals)


    if ser.getCTS() == False:
        if use_utc:
            utc = time.gmtime()
            Ea[4] = utc[1]
            Ea[5] = utc[2]
            Ea[6] = (0xff00 & utc[0]) >> 8
            Ea[7] = 0xff & utc[0]
            Ea[8] = utc[3]
            Ea[9] = utc[4]
            Ea[10] = utc[5]
        else:
            Ea[10] += 1
            if Ea[10] >= 60:
                Ea[10] = 0
                Ea[9] += 1
                if Ea[9] >= 60:
                    Ea[9] = 0
                    Ea[8] += 1
                    if Ea[8] >= 24:
                        Ea[8] = 0

        print Ea[4], Ea[5], Ea[8], Ea[9], Ea[10]

        En[12] = utc[1]
        En[13] = utc[2]
        En[14] = (0xff00 & utc[0]) >> 8
        En[15] = 0xff & utc[0]
        En[16] = utc[3]
        En[17] = utc[4]
        En[18] = utc[5]+1

        secs = secs + 1
        checksum(Ea)
        checksum(En)
        time.sleep(0.0742)
        ser.write(Ea)
        ser.write(En)
        if secs % 2 == 0:
            checksum(Bb)
            ser.write(Bb)
        if secs % 5 == 0:
            checksum(Ap)
            ser.write(Ap)
        if secs % 30 == 0:
            checksum(Aw)
            ser.write(Aw)
        if secs % 21 == 0:
            checksum(Ag)
            ser.write(Ag)
        if secs % 22 == 0:
            checksum(At)
            ser.write(At)
        if secs % 23 == 0:
            checksum(Az)
            ser.write(Az)
        if secs % 24 == 0:
            checksum(Bj)
            ser.write(Bj)
        if secs % 25 == 0:
            checksum(Bo)
            ser.write(Bo)

#        checksum(Ec)
#        ser.write(Ec)
        #print Ea
        #print ''.join(format(x, '02x') for x in Ea)

